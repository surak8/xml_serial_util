//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.CodeDom;
using System.CodeDom.Compiler;
using System.ComponentModel;
using System.Diagnostics;
using System.IO;
using System.Reflection;
using System.Text;
using System.Windows.Forms;
using System.Xml;
using System.Xml.Serialization;
using Microsoft.CSharp;

namespace NSLaserCfg {

    public partial class LaserCfgForm {
        public LaserCfgForm() {
            InitializeComponent();
        }
        void exitClick(object sender, EventArgs ea) {
            CancelEventArgs cea = new CancelEventArgs();

            Application.Exit(cea);
            if (cea.Cancel) {
                return;
            }
            Application.Exit();
        }
        void formLoad(object sender, EventArgs ea) {
        }
        [STAThread()]
        public static void Main(string[] args) {
            Application.EnableVisualStyles();
            Application.SetCompatibleTextRenderingDefault(false);
            Application.Run(new LaserCfgForm());
        }


        CodeCompileUnit ccu;
        CodeNamespace ns;
        bool issueFound = false;

        const string OPEN_PATH = @"\\appdeploy\APPDEPLOY\Colt Software\ColtMarking\ConfigFiles\LASERMARK-05";

        void tsmiOpen_Click(object sender, EventArgs e) {

            OpenFileDialog ofd = new OpenFileDialog();
            XmlDeserializationEvents xde;
            XmlSerializer xs;
            XmlReaderSettings xrs;
            StringBuilder sb;
            object anObj;

            ofd.InitialDirectory = OPEN_PATH;
            ofd.Filter = "Xml files|*.xml";
            ofd.FilterIndex = 0;

            if (ofd.ShowDialog() == DialogResult.OK) {
                ccu = new CodeCompileUnit();
                ccu.Namespaces.Add(ns = new CodeNamespace());
                try {
                    xs = new XmlSerializer(typeof(MarkingTaskGroup[]));
                    xrs = new XmlReaderSettings();
                    xrs.ValidationEventHandler += Xrs_ValidationEventHandler;
                    xrs.ValidationFlags = System.Xml.Schema.XmlSchemaValidationFlags.AllowXmlAttributes | System.Xml.Schema.XmlSchemaValidationFlags.ReportValidationWarnings;
                    using (XmlReader xr = XmlReader.Create(ofd.FileName, xrs)) {
                        xde = new XmlDeserializationEvents();
                        xde.OnUnknownAttribute = this.unknownAttribute;
                        xde.OnUnknownElement = this.unknownElement;
                        xde.OnUnknownNode = this.unknownNode;
                        xde.OnUnreferencedObject = this.unreferencedObject;
                        anObj = xs.Deserialize(xr, xde);
                        log(MethodBase.GetCurrentMethod());
                    }
                } catch (Exception ex) {
                    Trace.WriteLine(decomposeException(ex));
                } finally {
                    if (issueFound) {
                        showResult(sb = new StringBuilder());

                    }
                }
            }
        }

        void showResult(StringBuilder sb) {
            //throw new NotImplementedException();
            CodeDomProvider cdp = new CSharpCodeProvider();
            CodeGeneratorOptions opts = new CodeGeneratorOptions();
            opts.BlankLinesBetweenMembers = false;
            opts.ElseOnClosing = true;

            using (StringWriter xw = new StringWriter(sb = new StringBuilder())) {
                cdp.GenerateCodeFromCompileUnit(ccu, xw, opts);
            }
            Trace.WriteLine(sb.ToString());
        }

        void Xrs_ValidationEventHandler(object sender, System.Xml.Schema.ValidationEventArgs e) {
            log(MethodBase.GetCurrentMethod());
        }

        string decomposeException(Exception ex) {
            StringBuilder sb = new StringBuilder();
            Exception exo = ex;

            while (exo != null) {
                sb.AppendLine(exo.GetType().FullName + ":" + exo.Message);
                exo = exo.InnerException;
            }
            return sb.ToString();
        }

        void unreferencedObject(object sender, UnreferencedObjectEventArgs e) {
            this.log(MethodBase.GetCurrentMethod());
        }

        void unknownNode(object sender, XmlNodeEventArgs e) {
            int pos, n;
            string[] parts;
            string className, nameSpace;
            //CodeNamespace nsThis;
            //CodeTypeDeclaration ctd;

            if (e.ObjectBeingDeserialized != null) {

                if (!issueFound)
                    issueFound = true;
                parts = e.ObjectBeingDeserialized.GetType().FullName.Split('.');
                //if ((pos=))

                //Trace.WriteLine("here");
                if ((n = parts.Length) < 2) {
                    nameSpace = string.Empty;
                    className = parts[0];
                } else {
                    nameSpace = string.Join(".", parts, 0, n - 1);
                    className = parts[n - 1];
                }
                addToNamespace(nameSpace, className, e.Name);

            } else
                this.log(MethodBase.GetCurrentMethod(), "Found " + e.NodeType + " '" + e.Name + "' on " + e.ObjectBeingDeserialized.GetType().FullName);
        }

        void addToNamespace(string nameSpace, string className, string fieldName) {
            CodeNamespace nsThis = null;


            nsThis = null;
            foreach (CodeNamespace anns in ccu.Namespaces) {
                if (string.Compare(anns.Name, nameSpace) == 0) {
                    nsThis = anns;
                    break;
                }
            }
            if (nsThis == null)
                ccu.Namespaces.Add(nsThis = new CodeNamespace(nameSpace));
            addTypeInfo(nsThis, className, fieldName);
        }

        void addTypeInfo(CodeNamespace nsThis, string className, string fieldName) {
            CodeTypeDeclaration ctd = null;
            foreach (CodeTypeDeclaration atype in nsThis.Types)
                if (string.Compare(atype.Name, className, true) == 0) {
                    ctd = atype;
                    break;
                }
            if (ctd == null) {
                nsThis.Types.Add(ctd = new CodeTypeDeclaration(className));
                ctd.IsPartial = true;
            }
            addField(ctd, fieldName);
        }

        void addField(CodeTypeDeclaration ctd, string fieldName) {
            CodeMemberField f = null;

            foreach (CodeTypeMember ctm in ctd.Members) {
                if (ctm is CodeMemberField) {
                    if (string.Compare(ctm.Name, fieldName, true) == 0) {
                        f = ctm as CodeMemberField;
                        f.Attributes = MemberAttributes.Public;
                    }
                }
            }
            if (f == null) {
                ctd.Members.Add(f = new CodeMemberField(typeof(string), "_" + Char.ToLower(fieldName[0]) + fieldName.Substring(1)));
                f.Attributes = MemberAttributes.Public;
                f.CustomAttributes.Add(
                    new CodeAttributeDeclaration(
                        new CodeTypeReference(typeof(XmlElementAttribute)),
                        new CodeAttributeArgument(new CodePrimitiveExpression(fieldName))));
            }
        }

        void unknownElement(object sender, XmlElementEventArgs e) {
            this.log(MethodBase.GetCurrentMethod(), e.ObjectBeingDeserialized.GetType() + ": found " + e.Element.Name);
        }

        void unknownAttribute(object sender, XmlAttributeEventArgs e) {
            this.log(MethodBase.GetCurrentMethod());
        }

        void log(MethodBase mb) {
            Trace.WriteLine(mb.ReflectedType.Name + "." + mb.Name);
        }
        void log(MethodBase mb, string msg) {
            Trace.WriteLine(mb.ReflectedType.Name + "." + mb.Name + ":" + msg);
        }
        void log(string msg) {
            Trace.WriteLine(msg);
        }
        //kc}
    }

    //[XmlRoot("MarkingTaskGroup")]
    [XmlRoot]
    public class MarkingTaskGroup {
        //[XmlElement("IsActive")]
        //public bool isActive;
        //[XmlElement("IsStartUp")]
        //public bool isStartup;

        //[XmlElement("IsEndAutorun")]
        //public bool isEndAutorun;

        //[XmlElement("IsFalseAutorun")]
        //public bool isFalseAutorun;

        //[XmlElement("IsFalseAutorun")]
        //public bool isFalseAutorun;
        ////[XmlElement("IsStartUp")]
        ////public bool isStartup;
        ////[XmlElement("IsStartUp")]
        ////public bool isStartup;
        ////[XmlElement("IsStartUp")]
        ////public bool isStartup;

    }
}