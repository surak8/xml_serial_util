//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.CodeDom;
using System.CodeDom.Compiler;
using System.ComponentModel;
using System.Diagnostics;
using System.IO;
using System.Reflection;
using System.Text;
using System.Windows.Forms;
using System.Xml;
using System.Xml.Schema;
using System.Xml.Serialization;
using Microsoft.CSharp;

namespace NSLaserCfg {
        public partial class LaserCfgForm {
        #region ctor
        public LaserCfgForm() {
            InitializeComponent();
        }
        #endregion

        #region event-handling methods
        void exitClick(object sender, EventArgs ea) {
            CancelEventArgs cea = new CancelEventArgs();

            Application.Exit(cea);
            if (cea.Cancel) {
                return;
            }
            Application.Exit();
        }
        void formLoad(object sender, EventArgs ea) {
        }

        #endregion

        #region main-line method
        [STAThread()]
        public static void Main(string[] args) {
            Application.EnableVisualStyles();
            Application.SetCompatibleTextRenderingDefault(false);
            Application.Run(new LaserCfgForm());
        }

        #endregion

        #region fields
        CodeCompileUnit ccu;
        CodeNamespace ns;
        bool issueFound = false;
        #endregion

        #region constants
        const string OPEN_PATH = @"\\appdeploy\APPDEPLOY\Colt Software\ColtMarking\ConfigFiles\LASERMARK-05";

        #endregion

        void tsmiOpen_Click(object sender, EventArgs e) {

            OpenFileDialog ofd = new OpenFileDialog();
            //XmlDeserializationEvents xde;
            //XmlSerializer xs;
            //XmlReaderSettings xrs;
            //StringBuilder sb;
            //object anObj;

            ofd.InitialDirectory = OPEN_PATH;
            ofd.Filter = "Xml files|*.xml";
            ofd.FilterIndex = 0;

            if (ofd.ShowDialog() == DialogResult.OK) {
                inferSchema(ofd.FileName);
                //doDeserialization(ofd.FileName);
//foreach(var avar in )
            }
        }

          void inferSchema(string fileName) {
            try {
                //XmlSchemaImporter xsi KC= new XmlSchemaImporter();
                XmlSchemaInference xsi;
                XmlReaderSettings xrs = new XmlReaderSettings();
                //XmlParserContext ctx=new XmlParserContext(KC)

                xsi = new XmlSchemaInference();
                using (XmlReader xr = XmlReader.Create(fileName, xrs)) {
                    var v = xsi.InferSchema(xr);
                    //Trace.WriteLine("here");
                    //foreach (var avar in v.Schemas()) {
                    //    Trace.WriteLine("here");
                    //    //foreach (var avar2 in v.e) {

                    //    //}
                    //}
                    foreach (XmlSchema xs in v.Schemas()) {
                        //Trace.WriteLine("here");
                        //foreach(var avar in xs.Items) {
                        //    Trace.WriteLine("here");

                        //}
                        foreach (XmlSchemaElement xse in xs.Items) {
                            //Trace.WriteLine("here");
                            Trace.WriteLine(xse.Name + ":" + xse.SchemaType + ", " + xse.ElementSchemaType + ", " + xse.SchemaTypeName);
                            if (xse.ElementSchemaType== System.Xml.Schema.XmlSchemaComplexType) {
                                System.Xml.Schema.XmlSchemaComplexType xsct;

                                xsct = xse as System.Xml.Schema.XmlSchemaComplexType;
                                Trace.WriteLine("here");
                            }
                        }
                        Trace.WriteLine("here");
                    }
                }
            } catch (Exception ex) {
                log(MethodBase.GetCurrentMethod(), ex);
            } finally { }
        }

        void doDeserialization(string filename) {
            XmlDeserializationEvents xde;
            XmlSerializer xs;
            XmlReaderSettings xrs;
            StringBuilder sb;
            object anObj;

            ccu = new CodeCompileUnit();
            ccu.Namespaces.Add(ns = new CodeNamespace());
            ns.Imports.AddRange(
                new CodeNamespaceImport[] {
                    new CodeNamespaceImport ("System.Xml"),
                    new CodeNamespaceImport ("System.Xml.Serialization"),
                });
            try {
                xs = new XmlSerializer(typeof(MarkingTaskGroup[]));
                xrs = new XmlReaderSettings();
                xrs.ValidationEventHandler += Xrs_ValidationEventHandler;
                xrs.ValidationFlags = System.Xml.Schema.XmlSchemaValidationFlags.AllowXmlAttributes | System.Xml.Schema.XmlSchemaValidationFlags.ReportValidationWarnings;
                using (XmlReader xr = XmlReader.Create(filename, xrs)) {
                    xde = new XmlDeserializationEvents();
                    xde.OnUnknownAttribute = this.unknownAttribute;
                    xde.OnUnknownElement = this.unknownElement;
                    xde.OnUnknownNode = this.unknownNode;
                    xde.OnUnreferencedObject = this.unreferencedObject;
                    anObj = xs.Deserialize(xr, xde);
                    log(MethodBase.GetCurrentMethod());
                }
            } catch (Exception ex) {
                Trace.WriteLine(decomposeException(ex));
            } finally {
                if (issueFound) {
                    showResult(sb = new StringBuilder());
                }
            }
        }

        void showResult(StringBuilder sb) {
            //throw new NotImplementedException();
            CodeDomProvider cdp = new CSharpCodeProvider();
            CodeGeneratorOptions opts = new CodeGeneratorOptions();
            opts.BlankLinesBetweenMembers = false;
            opts.ElseOnClosing = true;

            using (StringWriter xw = new StringWriter(sb = new StringBuilder())) {
                cdp.GenerateCodeFromCompileUnit(ccu, xw, opts);
            }
            Trace.WriteLine(sb.ToString());
        }

        void Xrs_ValidationEventHandler(object sender, System.Xml.Schema.ValidationEventArgs e) {
            log(MethodBase.GetCurrentMethod());
        }

        string decomposeException(Exception ex) {
            StringBuilder sb = new StringBuilder();
            Exception exo = ex;

            while (exo != null) {
                sb.AppendLine(exo.GetType().FullName + ":" + exo.Message);
                exo = exo.InnerException;
            }
            return sb.ToString();
        }

        void unreferencedObject(object sender, UnreferencedObjectEventArgs e) {
            this.log(MethodBase.GetCurrentMethod());
        }

        void unknownNode(object sender, XmlNodeEventArgs e) {
            int  n;
            string[] parts;
            string className, nameSpace;
            //CodeNamespace nsThis;
            //CodeTypeDeclaration ctd;

            if (e.ObjectBeingDeserialized != null) {

                if (!issueFound)
                    issueFound = true;
                parts = e.ObjectBeingDeserialized.GetType().FullName.Split('.');
                //if ((pos=))

                //Trace.WriteLine("here");
                if ((n = parts.Length) < 2) {
                    nameSpace = string.Empty;
                    className = parts[0];
                } else {
                    nameSpace = string.Join(".", parts, 0, n - 1);
                    className = parts[n - 1];
                }
                addToNamespace(nameSpace, className, e.Name);

            } else
                this.log(MethodBase.GetCurrentMethod(), "Found " + e.NodeType + " '" + e.Name + "' on " + e.ObjectBeingDeserialized.GetType().FullName);
        }

        void addToNamespace(string nameSpace, string className, string fieldName) {
            CodeNamespace nsThis = null;


            nsThis = null;
            foreach (CodeNamespace anns in ccu.Namespaces) {
                if (string.Compare(anns.Name, nameSpace) == 0) {
                    nsThis = anns;
                    break;
                }
            }
            if (nsThis == null) {
                ccu.Namespaces.Add(nsThis = new CodeNamespace(nameSpace));

            }
            addTypeInfo(nsThis, className, fieldName);
        }

        void addTypeInfo(CodeNamespace nsThis, string className, string fieldName) {
            CodeTypeDeclaration ctd = null;
            foreach (CodeTypeDeclaration atype in nsThis.Types)
                if (string.Compare(atype.Name, className, true) == 0) {
                    ctd = atype;
                    break;
                }
            if (ctd == null) {
                nsThis.Types.Add(ctd = new CodeTypeDeclaration(className));
                ctd.IsPartial = true;
                //ctd.CustomAttributes.Add(new CodeAttributeDeclaration(new CodeTypeReference(typeof(XmlRootAttribute))));
                ctd.CustomAttributes.Add(new CodeAttributeDeclaration("XmlRoot"));
            }
            addField(ctd, fieldName);
        }

        void addField(CodeTypeDeclaration ctd, string fieldName) {
            CodeMemberField f = null;
            string fname;

            fname = "_" + Char.ToLower(fieldName[0]) + fieldName.Substring(1);
            foreach (CodeTypeMember ctm in ctd.Members) {
                if (ctm is CodeMemberField) {
                    if (string.Compare(ctm.Name, fname, true) == 0) {
                        f = ctm as CodeMemberField;
                        f.Attributes = MemberAttributes.Public;
                    }
                }
            }
            if (f == null) {
                ctd.Members.Add(f = new CodeMemberField(typeof(string), fname));
                Trace.WriteLine("adding field: " + fname);
                f.Attributes = MemberAttributes.Public;
                f.CustomAttributes.Add(
                    new CodeAttributeDeclaration(
                        //new CodeTypeReference(typeof(XmlElementAttribute)),
                        "XmlElement",
                                               new CodeAttributeArgument(new CodePrimitiveExpression(fieldName))));
            }
        }

        void unknownElement(object sender, XmlElementEventArgs e) {
            this.log(MethodBase.GetCurrentMethod(), e.ObjectBeingDeserialized.GetType() + ": found " + e.Element.Name);
        }

        void unknownAttribute(object sender, XmlAttributeEventArgs e) {
            this.log(MethodBase.GetCurrentMethod());
        }

        void log(MethodBase mb) {
            Trace.WriteLine(makeSig(mb));
        }

          static string makeSig(MethodBase mb) {
            return mb.ReflectedType.Name + "." + mb.Name;
        }

        void log(MethodBase mb, string msg) {
            Trace.WriteLine(makeSig(mb) + ":" + msg);
        }
        void log(MethodBase mb, Exception ex) {
            Trace.WriteLine(makeSig(mb) ,decomposeException (ex));
        }

        void log(string msg) {
            Trace.WriteLine(msg);
        }
        //kc}
    }
}